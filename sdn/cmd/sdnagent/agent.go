package main

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
	"sync"
	"time"

	"github.com/lf-edge/eden/sdn/api"
	"github.com/lf-edge/eden/sdn/pkg/configitems"
	"github.com/lf-edge/eden/sdn/pkg/netmonitor"
	dg "github.com/lf-edge/eve/libs/depgraph"
	"github.com/lf-edge/eve/libs/reconciler"
	log "github.com/sirupsen/logrus"
)

const (
	// Port connecting SDN VM with the host
	hostPortLogicalLabel = "Host-Port"
	hostPortMACPrefix    = "08:33:33" // suffix is randomly generated by Eden
)

type agent struct {
	sync.Mutex
	ctx        context.Context
	netMonitor *netmonitor.NetworkMonitor

	// Network model
	netModel    api.NetworkModel
	newNetModel chan api.NetworkModel

	// Configuration state
	currentState  dg.Graph
	intendedState dg.Graph
	registry      reconciler.ConfiguratorRegistry
	failingItems  map[dg.ItemRef]error

	// Asynchronous operations
	resumeReconciliation <-chan string      // nil if no async ops
	cancelAsyncOps       context.CancelFunc // nil if no async ops
	waitForAsyncOps      func()             // NOOP if no async ops
}

func (a *agent) init() error {
	a.ctx = context.Background()
	a.netMonitor = &netmonitor.NetworkMonitor{}
	a.netMonitor.Init()
	netEvents := a.netMonitor.WatchEvents(a.ctx, "SDN-Agent")
	registry := &reconciler.DefaultRegistry{}
	if err := configitems.RegisterItems(registry, a.netMonitor); err != nil {
		return err
	}
	a.registry = registry
	a.newNetModel = make(chan api.NetworkModel, 10)
	a.failingItems = make(map[dg.ItemRef]error)
	// Initially start with an empty network model.
	// Ever-present config items will get created.
	// (e.g. DHCP client for the interface connecting SDN with the host)
	a.netModel = api.NetworkModel{}
	a.updateCurrentState()
	a.updateIntendedState()
	a.reconcile()
	go a.run(netEvents)
	return nil
}

func (a *agent) run(netEvents <-chan netmonitor.Event) {
	for {
		select {
		case netModel := <-a.newNetModel:
			// Network model is already validated, applying...
			a.Lock()
			a.netModel = netModel
			a.updateIntendedState()
			a.reconcile()
			a.Unlock()

		case <-a.resumeReconciliation:
			a.Lock()
			a.reconcile()
			a.Unlock()

		case event := <-netEvents:
			log.Debugf("Network event: %+v", event)
			switch ev := event.(type) {
			case netmonitor.NetIfChange:
				if ev.Added || ev.Deleted {
					a.Lock()
					changed := a.updateCurrentState()
					if a.isHostPort(ev.Attrs) {
						// Intended state for SDN<->Host connectivity changes
						// when the "host port" (dis)appears.
						a.updateIntendedState()
						changed = true
					}
					if changed {
						a.reconcile()
					}
					a.Unlock()
				}
			}

		case <-a.ctx.Done():
			a.Lock()
			if a.cancelAsyncOps != nil {
				a.cancelAsyncOps()
				a.waitForAsyncOps()
				log.Warn("Some asynchronous operations were canceled!")
			}
			a.Unlock()
			return
		}
	}
}

// Called with agent in locked state.
func (a *agent) reconcile() {
	reconcileStartTime := time.Now()
	r := reconciler.New(a.registry)
	status := r.Reconcile(a.ctx, a.currentState, a.intendedState)
	a.currentState = status.NewCurrentState

	// Update variables needed to resume reconciliation
	// after async operation(s).
	if status.AsyncOpsInProgress {
		log.Debug("Some config operations continue in the background")
	}
	a.cancelAsyncOps = status.CancelAsyncOps
	a.resumeReconciliation = status.ReadyToResume
	a.waitForAsyncOps = status.WaitForAsyncOps

	// Log every executed operation.
	for _, opLog := range status.OperationLog {
		var withErr string
		if opLog.Err != nil {
			withErr = fmt.Sprintf(" with error: %v", opLog.Err)
		}
		var verb string
		if opLog.InProgress {
			verb = "started async execution of"
		} else {
			if opLog.StartTime.Before(reconcileStartTime) {
				verb = "finalized async execution of"
			} else {
				// synchronous operation
				verb = "executed"
			}
		}
		log.Infof("State Reconciler %s %v for %v%s, content: %s",
			verb, opLog.Operation, dg.Reference(opLog.Item),
			withErr, opLog.Item.String())
	}

	// Log transitions from no-error to error and vice-versa.
	var failed, fixed []string
	for _, opLog := range status.OperationLog {
		itemRef := dg.Reference(opLog.Item)
		if opLog.Err != nil {
			a.failingItems[itemRef] = opLog.Err
		} else {
			delete(a.failingItems, itemRef)
		}
		if opLog.PrevErr == nil && opLog.Err != nil {
			failed = append(failed, fmt.Sprintf("%v (err: %v)", itemRef, opLog.Err))
		}
		if opLog.PrevErr != nil && opLog.Err == nil {
			fixed = append(fixed, itemRef.String())
		}
	}
	if len(failed) > 0 {
		log.Errorf("Newly failed config items: %s",
			strings.Join(failed, ", "))
	}
	if len(fixed) > 0 {
		log.Infof("Fixed config items: %s",
			strings.Join(fixed, ", "))
	}
}

// Find interface connecting SDN VM with the host based on the MAC address prefix.
func (a *agent) findHostInterface() (netmonitor.NetIf, bool) {
	for _, netIf := range a.netMonitor.ListInterfaces() {
		if a.isHostPort(netIf.NetIfAttrs) {
			return netIf, true
		}
	}
	return netmonitor.NetIf{}, false
}

func (a *agent) isHostPort(netIfAttrs netmonitor.NetIfAttrs) bool {
	return strings.HasPrefix(netIfAttrs.MAC.String(), hostPortMACPrefix)
}

func (a *agent) getNetModel(w http.ResponseWriter, r *http.Request) {
	a.Lock()
	resp, err := json.Marshal(a.netModel)
	a.Unlock()
	if err != nil {
		errMsg := fmt.Sprintf("failed to marshal network model to JSON: %v", err)
		log.Error(errMsg)
		http.Error(w, errMsg, http.StatusInternalServerError)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	if _, err = w.Write(resp); err != nil {
		log.Errorf("Failed to write network model to HTTP response: %v", err)
	}
}

func (a *agent) applyNetModel(w http.ResponseWriter, r *http.Request) {
	var netModel api.NetworkModel
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		errMsg := fmt.Sprintf("Failed to read network model from HTTP request: %v", err)
		log.Error(errMsg)
		http.Error(w, errMsg, http.StatusBadRequest)
		return
	}
	err = json.Unmarshal(body, &netModel)
	if err != nil {
		errMsg := fmt.Sprintf("Failed to unmarshal network model from JSON: %v", err)
		log.Error(errMsg)
		http.Error(w, errMsg, http.StatusBadRequest)
		return
	}
	err = a.validateNetModel(netModel)
	if err != nil {
		errMsg := fmt.Sprintf("Network model is invalid: %v", err)
		log.Error(errMsg)
		http.Error(w, errMsg, http.StatusBadRequest)
		return
	}
	a.newNetModel <- netModel
	w.WriteHeader(http.StatusOK)
}

func (a *agent) getNetConfig(w http.ResponseWriter, r *http.Request) {
	dotExporter := &dg.DotExporter{CheckDeps: true}
	a.Lock()
	dot, err := dotExporter.ExportTransition(a.currentState, a.intendedState)
	a.Unlock()
	if err != nil {
		errMsg := fmt.Sprintf("Failed to export network config to DOT: %v", err)
		log.Error(errMsg)
		http.Error(w, errMsg, http.StatusInternalServerError)
		return
	}
	w.Header().Set("Content-Type", "text/vnd.graphviz")
	w.WriteHeader(http.StatusOK)
	if _, err = w.Write([]byte(dot)); err != nil {
		log.Errorf("Failed to write network config to HTTP response: %v", err)
	}
}

func (a *agent) getSDNStatus(w http.ResponseWriter, r *http.Request) {
	status := api.SDNStatus{}
	if hostNetIf, found := a.findHostInterface(); found {
		for _, ip := range hostNetIf.IPs {
			if ip.IP.IsGlobalUnicast() {
				status.MgmtIPs = append(status.MgmtIPs, ip.IP.String())
			}
		}
	}
	a.Lock()
	for itemRef, err := range a.failingItems {
		status.ConfigErrors = append(status.ConfigErrors, api.ConfigError{
			ItemRef: itemRef,
			ErrMsg:  err.Error(),
		})
	}
	a.Unlock()
	resp, err := json.Marshal(status)
	if err != nil {
		errMsg := fmt.Sprintf("failed to marshal SDN status to JSON: %v", err)
		log.Error(errMsg)
		http.Error(w, errMsg, http.StatusInternalServerError)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	if _, err = w.Write(resp); err != nil {
		log.Errorf("Failed to write SDN status to HTTP response: %v", err)
	}
}
